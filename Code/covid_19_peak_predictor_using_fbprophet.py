# -*- coding: utf-8 -*-
"""Covid-19-Peak-Predictor-using FBProphet.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bH-_JYrilXCcDKf9l-ki5DlmClv-XB90

# Covid-19-Peak-Predictor-using-ARIMA-LSTM-and-FBProphet
1. Data Source from OUR WORLD in Data GitHub repository.
2. Goal to predict COVID-19 peak using Time Series Analysis
3. Dataset available here: https://github.com/owid/covid-19-data/blob/master/public/data/owid-covid-data.csv
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import seaborn as sns
import scipy
from matplotlib import dates
from fbprophet import Prophet
import pandas as pd
import matplotlib.pyplot as plt 
import numpy as np
from IPython.display import Javascript
from datetime import datetime
from pandas.api.types import is_numeric_dtype
from google.colab import files
import os
import time
import getpass
import statistics
import math
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.pylab import rcParams
import statsmodels.api as sm
from pylab import rcParams
import missingno as msno
!pip install geopandas #for map
import geopandas as gpd
from pandas import DataFrame
from pandas import to_datetime
import ast



import seaborn as sns
sns.set_style('whitegrid')
pd.set_option('display.max_rows', 55)

#import sklearn packages
from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import StandardScaler, MinMaxScaler

#import statsmodels
import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller #Dickey-Fuller Test
from statsmodels.tsa.seasonal import seasonal_decompose 
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.arima_model import ARIMA
from statsmodels.tools.eval_measures import rmse
from statsmodels.tsa.holtwinters import Holt

#Import ARIMA packages
!pip install pmdarima
import pmdarima as pm
from pmdarima.model_selection import train_test_split
from pmdarima.arima import ADFTest

# Use bokeh to plot predictions
import bokeh.io
bokeh.io.reset_output()
bokeh.io.output_notebook()
from bokeh.plotting import figure, show, output_notebook
from bokeh.io import output_notebook
from bokeh.models import Legend
from bokeh.models import NumeralTickFormatter

#loading the URL
covid_url = 'https://raw.githubusercontent.com/owid/covid-19-data/master/public/data/owid-covid-data.csv'
#read the CSV file
cdata = pd.read_csv(covid_url, error_bad_lines=False)

#Number of columns
cdata.head()

#Display all rows
pd.set_option('display.max_rows',None)

#Total rows
cdata.shape

len(cdata.index)

len(cdata.columns)

#Checking for null values
cdata.isnull().sum()

#Dropping unrequired columns
cdata.drop(['excess_mortality_cumulative_per_million','excess_mortality_cumulative_absolute','excess_mortality_cumulative','excess_mortality','human_development_index','hospital_beds_per_thousand','handwashing_facilities','male_smokers','female_smokers','gdp_per_capita','diabetes_prevalence','cardiovasc_death_rate','extreme_poverty','gdp_per_capita','population_density','reproduction_rate','continent'],axis=1, inplace= True)

cdata.head()

#Checking columns with 80% null values 
cdata.isnull().sum() >= (119656 * 0.80)

# dropping column with 80% null values
cdata.drop(['icu_patients','icu_patients_per_million','hosp_patients','hosp_patients_per_million','weekly_hosp_admissions','weekly_hosp_admissions_per_million','weekly_icu_admissions','weekly_icu_admissions_per_million'],axis=1,inplace= True)

cdata.head(1)

#Checking null values using heatmap
plt.subplots(figsize=(20,15))
sns.heatmap(cdata.isnull(), cbar=False)

#Fill NaN values with 0
cdata.fillna(0,inplace=True)

#Checking if any null values remains
cdata.isnull().sum()

cdata.head(10)

#Checking if any null values remains using heatmap
plt.subplots(figsize=(20,15))
sns.heatmap(cdata.isnull(), cbar=False)

#Getting names of all the available nation in dataset
cdata['location'].unique()

#Ploting location vs new cases per million
plt.figure(figsize=(15,10))
plt.title("New cases per million in different nation",fontsize='14',loc='left')
graph = sns.lineplot(data=cdata[cdata['location'].isin(['Norway'])].sort_values(by='date'), x='date', y='new_cases_per_million',hue='location')
graph.xaxis.set_major_locator(mdates.DayLocator(interval = 60))
plt.xticks(rotation = 'vertical')
plt.show()

#Plotting People fully vaccinated in USA
plt.figure(figsize=(20,5))
plt.title("Positive rate vs New cases per million",fontsize='14',loc='left')
sns.lineplot(data=cdata[cdata['location'].isin(['United States','Germany','United Kingdom','Europe','Israel','Indonesia'])].sort_values(by='date'), x='positive_rate', y='new_cases_per_million',hue='location')
plt.show()

#Plotting People fully vaccinated in USA
plt.figure(figsize=(20,5))
plt.title("Strigency index vs New cases per million",fontsize='14',loc='left')
sns.lineplot(data=cdata[cdata['location'].isin(['United States','Germany','United Kingdom','Europe','Israel','Indonesia'])].sort_values(by='date'), x='stringency_index', y='new_cases_per_million',hue='location')
plt.show()

plt.figure(figsize=(20,5))
plt.title("Strigency index vs Positive rate",fontsize='14',loc='left')
sns.lineplot(data=cdata[cdata['location'].isin(['United States','Germany','United Kingdom','Europe','Israel','Indonesia','Australia'])].sort_values(by='date'), x='stringency_index', y='positive_rate',hue='location')
plt.show()

#Plotting WORLDMAP for Stringency index
#Using geopandas datset naturalearth lowres
world = gpd.read_file(gpd.datasets.get_path('naturalearth_lowres'))
world.head(10)

#We will join both the data for covid and world map and join it on iso_code
merged = world.set_index('iso_a3').join(cdata.set_index('iso_code')).reset_index()

merged.head(3)

#Plotting WORLDMAP for Stringency index
def graph_world(feature):
    #whichever data we wish to map we will send in feature
    to_be_mapped = feature
    vmin, vmax = 0,100
    fig, ax = plt.subplots(1, figsize=(25,25))

    merged.plot(column=to_be_mapped, cmap='RdYlGn', linewidth=0.8, ax=ax, edgecolors='1' , legend=True,
                legend_kwds={'label': "new_cases_per_million", 'orientation': "horizontal"})
    ax.set_title('New cases per million', fontdict={'fontsize':20})

#Plotting WORLDMAP for Stringency index
graph_world('new_cases_per_million')

#Plotting Stringency index in different nations
plt.figure(figsize=(150,30))
plt.title('Stringency index in different nations',fontsize = 20,loc='left')
sns.lineplot(data=cdata[cdata['location'].isin(['United States','Israel','United Kingdom','Europe','Australia'])].sort_values(by='date'), x='stringency_index', y='new_cases',hue='location')
plt.xticks(rotation = 'vertical')
plt.show()



#Plotting Positive rate in different nations
plt.figure(figsize=(150,30))
plt.title('Positive rate in different nations',fontsize = 20,loc='left')
sns.lineplot(data=cdata[cdata['location'].isin(['United States','India'])].sort_values(by='date'), x='date', y='positive_rate',hue='location')
plt.xticks(rotation = 'vertical')
plt.show()

"""# FBProphet Forecast"""

#FBProphet model
def forecast(nation):
  data = cdata[cdata['location'].isin([nation])].sort_values(by="date")[['date',"new_cases_per_million"]]
  data.columns = ['ds','y']
  model = Prophet(daily_seasonality=False,weekly_seasonality=False,yearly_seasonality=True,interval_width=0.95)
  model.add_seasonality(name='monthly', period=30.5, fourier_order=5)
  model.fit(data)
  future = model.make_future_dataframe(periods=365, freq='D')
  pred = model.predict(future)
  model.plot(pred);
  model.plot_components(pred);



m = forecast('Norway');

#future = list()
#for i in range(1, 13):
#  date = '2021-%01d' % i
#  future.append([date])
#for i in range(1, 13):
#  date = '2022-%12d' % i
#  future.append([date])
#future = DataFrame(future)
#future.columns = ['ds']
#future['ds']= to_datetime(future['ds'])

"""### FBProphet forecast with regressor """

#FBProphet model with regressor
def forecast2(nation):
  data2 = cdata[cdata['location'].isin([nation])].sort_values(by="date").rename(columns={'new_cases_per_million':'y','date':'ds'})
  model2 = Prophet(weekly_seasonality=False,yearly_seasonality=True,interval_width=0.95)
  model2.add_seasonality(name='monthly', period=30.5, fourier_order=5)
  temp = cdata[cdata['location'].isin([nation])].sort_values(by="date")

  def positive_rate(ds):
    date = (pd.to_datetime(ds)).date()
    return (temp['positive_rate']).values[0]

  def stringency_index(ds):
    date = (pd.to_datetime(ds)).date()
    return (temp['stringency_index']).values[0]    

  #model2.add_regressor('positive_rate')
  model2.add_regressor('stringency_index')
  model2.fit(data2)

  future2 = model2.make_future_dataframe(periods=365)
  #future2['positive_rate'] = future2['ds'].apply(positive_rate)
  future2['stringency_index'] = future2['ds'].apply(stringency_index)
  
  pred2 = model2.predict(future2)
  model2.plot(pred2);
  
  #future2['positive_rate'] = temp['positive_rate'] 
  #future2['people_vaccinated_per_hundred'] = temp['people_vaccinated_per_hundred']

#FBProphet model without regressor
from fbprophet.diagnostics import cross_validation
from fbprophet.diagnostics import performance_metrics
from fbprophet.plot import plot_cross_validation_metric
import itertools


def forecast3(nation):
  data = cdata[cdata['location'].isin([nation])].sort_values(by="date")[['date',"new_cases_per_million"]]
  data.columns = ['ds','y']
  model = Prophet(daily_seasonality=False,weekly_seasonality=False,yearly_seasonality=True,interval_width=0.95)
  model.add_seasonality(name='monthly', period=30.5, fourier_order=5)
  model.fit(data)
  future = model.make_future_dataframe(periods=365, freq='D')
  pred = model.predict(future)
  model.plot(pred);

  df_cv = cross_validation(model, initial='365 days', period='90 days', horizon = '200 days')
  df_p = performance_metrics(df_cv)
  #print(df_p))
  fig3 = plot_cross_validation_metric(df_cv, metric='rmse')

#List of countries with high new cases, positive rate and people_fully_vaccinated_per_hundred
clist = cdata.sort_values(by="new_cases_per_million",ascending=False)
clist2 = clist.sort_values(by="people_fully_vaccinated_per_hundred",ascending=False)
clist2 = clist.sort_values(by="positive_rate",ascending=False)
clist2['location'].head(2000).unique()

#data = cdata[cdata['location'].isin(['United Kingdom'])].sort_values(by="date")[['date',"new_cases_per_million"]]
#data.set_index('date', inplace=True)
#c = data.loc['0':'2021-04-30']
#df = c.reset_index()
#df.columns = ['ds','y']
#model = Prophet(daily_seasonality=False,weekly_seasonality=False,yearly_seasonality=True,interval_width=0.95)
#model.fit(df)
#future = model.make_future_dataframe(periods=365, freq='D')
#pred = model.predict(future)
#model.plot(pred);

#FBProphet model without regressor and feeding partial data til 2021-04-30
def forecast4(nation):
  data = cdata[cdata['location'].isin([nation])].sort_values(by="date")[['date',"new_cases_per_million"]]
  data.set_index('date', inplace=True)
  c = data.loc['0':'2021-04-30']
  df = c.reset_index()
  df.columns = ['ds','y']
  model = Prophet(daily_seasonality=False,weekly_seasonality=False,yearly_seasonality=True,interval_width=0.95)
  model.add_seasonality(name='monthly', period=30.5, fourier_order=5)
  model.fit(df)
  future = model.make_future_dataframe(periods=365, freq='D')
  pred = model.predict(future)
  model.plot(pred);

forecast2('Italy')
forecast3('Italy')
forecast4('Italy')

"""# Hyper-parameter Tunning

"""

def Tunning(nation):  
  data = cdata[cdata['location'].isin([nation])].sort_values(by="date")[['date',"new_cases_per_million"]]
  data.columns = ['ds','y']

  def create_param_combinations(**param_dict):
    param_iter = itertools.product(*param_dict.values())
    params =[]
    for param in param_iter:
        params.append(param) 
    params_df = pd.DataFrame(params, columns=list(param_dict.keys()))
    return params_df

  def single_cv_run(history_df, metrics, param_dict):
    m = Prophet(**param_dict)
    m.fit(history_df)
    df_cv = cross_validation(m, initial='400 days', period='90 days', horizon = '180 days')
    df_p = performance_metrics(df_cv).mean().to_frame().T
    df_p['params'] = str(param_dict)
    #df_p = df_p.loc[:, metrics]
    df_p = df_p.reindex(columns = metrics)
    return df_p

  param_grid = {  
                'changepoint_prior_scale': [0.005, 0.05, 0.5, 5],
                'changepoint_range': [0.8, 0.9],
                'seasonality_prior_scale':[0.1, 1, 10.0],
                'seasonality_mode': ['multiplicative', 'additive'],
                'growth': ['linear'],
                'yearly_seasonality': [5, 10, 20]
              }

  metrics = ['horizon', 'rmse', 'mape', 'params'] 
  results = []
  params_df = create_param_combinations(**param_grid)
  for param in params_df.values:
    param_dict = dict(zip(params_df.keys(), param))
    cv_df = single_cv_run(data,  metrics, param_dict)
    results.append(cv_df)
  results_df = pd.concat(results).reset_index(drop=True)
  best_param = results_df.loc[results_df['mape'] == min(results_df['mape']), ['params']]
  print(f'\n The best param combination is {best_param.values[0][0]}')
  m = best_param.values[0][0]
  return m

from fbprophet.diagnostics import cross_validation
from fbprophet.diagnostics import performance_metrics
from fbprophet.plot import plot_cross_validation_metric
import itertools

def final_forecast(nation):
  q = Tunning(nation)
  #print("Q:",q)
  n = ast.literal_eval(q)
  m = ast.literal_eval(q)
  dd = []
  for key, value in m.items():
    print(str(key), str(value))
    dd.append((key,value))

  changepoint_prior_scale = dd[0][0]
  changepoint_prior_scale_no = dd[0][1]

  changepoint_range = dd[1][0]
  changepoint_range_no = dd[1][1]

  seasonality_prior_scale = dd[2][0]
  seasonality_prior_scale_no = dd[2][1]

  seasonality_mode = dd[3][0]
  seasonality_mode_no = dd[3][1]

  growth = dd[4][0]
  growth_no = dd[4][1]

  yearly_seasonality = dd[5][0]
  yearly_seasonality_no = dd[5][1]

  def forecast5(nation):
    data = cdata[cdata['location'].isin([nation])].sort_values(by="date")[['date',"new_cases_per_million"]]
    data.set_index('date', inplace=True)
    c = data.loc['0':'2021-04-30']
    df = c.reset_index()
    df.columns = ['ds','y']
    model = Prophet(changepoint_prior_scale= changepoint_prior_scale_no, changepoint_range= changepoint_range_no, seasonality_prior_scale= seasonality_prior_scale_no, seasonality_mode= seasonality_mode_no, growth= growth_no, yearly_seasonality= yearly_seasonality_no)
    model.add_seasonality(name='monthly', period=30.5, fourier_order=5)
    model.fit(df)
    future = model.make_future_dataframe(periods=365, freq='D')
    pred = model.predict(future)
    model.plot(pred);


  def forecast6(nation):
    data = cdata[cdata['location'].isin([nation])].sort_values(by="date")[['date',"new_cases_per_million"]]
    data.columns = ['ds','y']
    model = Prophet(changepoint_prior_scale= changepoint_prior_scale_no, changepoint_range= changepoint_range_no, seasonality_prior_scale= seasonality_prior_scale_no, seasonality_mode= seasonality_mode_no, growth= growth_no, yearly_seasonality= yearly_seasonality_no)
    model.add_seasonality(name='monthly', period=30.5, fourier_order=5)
    model.fit(data)
    future = model.make_future_dataframe(periods=365, freq='D')
    pred = model.predict(future)
    model.plot(pred);

    df_cv = cross_validation(model, initial='365 days', period='90 days', horizon = '200 days')
    df_p = performance_metrics(df_cv)
    fig = plot_cross_validation_metric(df_cv, metric='rmse')

  forecast5(nation)
  forecast6(nation)

clist = cdata.sort_values(by="new_cases_per_million",ascending=False)
clist2 = clist.sort_values(by="people_fully_vaccinated_per_hundred",ascending=False)
clist2 = clist.sort_values(by="positive_rate",ascending=False)
clist2['location'].head(5000).unique()

#Tunning('Thailand')
final_forecast('Italy')